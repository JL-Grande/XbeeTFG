\chapter{Anexo A}

El Anexo A recoge y explica los procesos de instalación y configuración de los diferentes sistemas operativos, programas y herramientas necesarios para la implementación del proyecto.

% Configuración de la visualización del código SW
\lstset{backgroundcolor=\color{verde_p}, language=bash, breaklines=true, basicstyle=\footnotesize, xleftmargin=25pt, framesep=8pt, numbersep=15pt}


\section{Instalación de Raspbian OS}\label{anexo:raspbian}

Raspbian es un sistema operativo orientado a Raspberry Pi por lo que existe multitud de documentación complementaria en la web oficial\cite{Raspberry:2019}

Antes de comenzar a instalar el sistema operativo en una tarjeta microSD, se debe comprobar que ésta reúne los requisitos para ser usada en esta aplicación. Uno de estos requisitos es que la capacidad de la tarjeta sea superior a 8GB. Sin embargo, el uso de tarjetas de un tamaño superior a 32GB hace que sea necesario formatear la tarjeta antes de instalar el sistema operativo. Esto es debido a que el formato de serie (exFAT) no es compatible con el bootloader de Raspberry Pi, por lo que se deberá aplicar el formato FAT16 o FAT32 previamente.

Las instrucciones están pensadas teniendo en cuenta que se posee un ordenador con sistema operativo Windows.

\begin{enumerate}
\item \textbf{Descargar el sistema operativo}

Se puede descargar la imagen desde la web de descargas de Raspberry Pi\footnote{\url{https://www.raspberrypi.org/downloads/raspbian/}}

\begin{figure}[tb]
\centering
\includegraphics[width=0.5\textwidth]{figuras/RaspbianDwIcon.png}
\caption{Descarga de Raspbian Stretch}
\label{fig:descargaRaspbian}
\end{figure}

\item \textbf{Descargar e instalar Etcher}

Se precisa de una herramienta de escritura de imágenes y Etcher es la solución más sencilla para la mayoría de usuarios. Permite la escritura de la imagen sin la necesidad de extraer el archivo zip. 


\item \textbf{Escribir la imagen a una microSD}

Seleccionar el archivo de la imagen  la SD de destino es suficiente para flashear la imagen.

\item Una vez acabado el proceso de descompresión, la instalación debería estar completada. Introduciendo la tarjeta micro SD en su correspondiente posición en la Raspberry Pi, ésta acederá a Raspbian para arrancar el sistema.

\item Para comprobar la version del SO instalado, se puede hacer uso del comando \textit{lsb-release}

\begin{lstlisting}[frame=single, label=command:lsb]
lsb_release -a
\end{lstlisting}

\begin{figure}[tb]
\centering
\includegraphics[width=0.5\textwidth]{figuras/RaspbianVersion.png}
\caption{Versión de Raspbian}
\label{fig:versionRaspbian}
\end{figure}

\end{enumerate}


\section{Instalación MQTT en Raspbian OS}\label{anexo:mqtt}

Mosquitto (broker de MQTT) se instala de igual manera que cualquier otra aplicación, haciendo uso de los repositorios.

En primer lugar, se actualizan los repositorios.

\begin{lstlisting}[frame=single, label=command:installmqtt1]
sudo apt-get update
\end{lstlisting}

Posteriormente, se instala Mosquitto.

\begin{lstlisting}[frame=single, label=command:installmqtt2]
sudo apt-get install mosquitto
\end{lstlisting}

Si todo va bien, al terminar el proceso, MQTT debería estar instalado.

Para probar la instalación, se pueden usar clientes de MQTT para enviar y recibir información a través un topic de prueba. Estos clientes son, por ejemplo, \textit{IoT MQTT Dashboard} en Android o \textit{MQTT.fx} en Windows.

\section{Edición y compilación de scripts en Raspbian OS}\label{anexo:scripts}



\chapter{Anexo B}

En el Anexo B se sitúan los desarrollos software íntegros que forman parte del proyecto.

% Esto para configurar como se va a visualizar el código
\lstset{numbers=left,numberstyle=\tiny, language=Python, breaklines=true, basicstyle=\footnotesize, xleftmargin=25pt, framesep=8pt, numbersep=15pt}

\section{Código SendAT.py}

\begin{lstlisting}[frame=leftline, caption={SendAT.py}, label=code:SendAT]
#!/usr/bin/env python
import sys
import time
import serial
import logging

logging.basicConfig(filename='/home/pi/Xbee/SendLogs/sentAT.log',level=logging.DEBUG,format='%(asctime)s %(message)s')

ser = serial.Serial(
	port='/dev/ttyACM0',
	baudrate = 115200,
	parity=serial.PARITY_NONE,
	stopbits=serial.STOPBITS_ONE,
	bytesize=serial.EIGHTBITS,
	timeout=1
)

if len(sys.argv)<2:
	param = bytearray([0x8C,0x5A])
	logging.warning('AT Package non-definde values')
else:
	param = sys.argv[1]
	
val1 = param[0]+param[1]
val2 = param[3]+param[4]
var1 = int(val1,16)
var2 = int(val2,16)
checksum_rha = (~(6+2+var1+var2+125) & 0xFF)
	
if var1>124 and var1<167 and var2>59 and var2<111:
        values = bytearray([0xFF, 0xFF, 0x06, 0x02, 0x7D, var1, var2, checksum_rha])
        ser.write(values)
        logging.info('AT Package sent')
else:
        logging.warning('AT Package out of range')
    

\end{lstlisting}

\section{Código SendAPI.py}

\begin{lstlisting}[frame=leftline, caption={SendAPI.py}, label=code:SendAPI]
#!/usr/bin/env python
import sys
import time
import serial
import logging

logging.basicConfig(filename='/home/pi/Xbee/SendLogs/sentAPI.log',level=logging.DEBUG,format='%(asctime)s %(message)s')

ser = serial.Serial(
	port='/dev/ttyACM0',
	baudrate = 115200,
	parity=serial.PARITY_NONE,
	stopbits=serial.STOPBITS_ONE,
	bytesize=serial.EIGHTBITS,
	timeout=1
)

if len(sys.argv)<2:
	param = bytearray([0x8C,0x5A])
	logging.warning('API Package non-definde values')
else:
	param = sys.argv[1]
	
val1 = param[0]+param[1]
val2 = param[3]+param[4]
var1 = int(val1,16)
var2 = int(val2,16)

checksum_rha = (~(6+2+var1+var2+125) & 0xFF)
checksum_xbee = (~(16+1+5*255+254+6+2+var1+var2+125+checksum_rha) & 0xFF)

if var1>124 and var1<167 and var2>59 and var2<111:
        values = bytearray([0x7E, 0x00, 0x16, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0x06, 0x02, 0x7D, var1, var2, checksum_rha, checksum_xbee])

        #print(hex(values[x]))
                
        ser.write(values)
        logging.info('API Package sent')
        
else:
        logging.warning('API Package out of range')
\end{lstlisting}

\section{Código Receive.py}

\begin{lstlisting}[frame=leftline, caption={Receive.py}, label=code:Receive]
#!/usr/bin/env python
import sys
import time
import serial
import struct
import logging

logging.basicConfig(filename='/home/pi/Xbee/ReceiveLogs/receiveAT.log',level=logging.DEBUG,format='%(asctime)s %(message)s')

ser = serial.Serial(
	port='/dev/ttyACM0',
	baudrate = 115200,
	parity=serial.PARITY_NONE,
	stopbits=serial.STOPBITS_ONE,
	bytesize=serial.EIGHTBITS,
	timeout=1
)

def serialReader():
    b = ser.read()
    if b:
        bs = struct.unpack("<B",b)
        return int(bs[0])
    else:
        return -1

while True:
        if serialReader() == 255 and serialReader() == 255:
            length = serialReader()
            data = [0]*length
            for x in xrange(length):
                data[x] = serialReader()
            if data[0] == 0: # 0 means an UPDATE_INFO package
                dev = [data[6],data[11]]
                logging.info(data)
                print(dev,file=sys.stderr)
\end{lstlisting}

\chapter{Anexo C}

El Anexo C recoge la documentación de interés de distintos componentes del proyecto

\section{Datasheet XBee Shield}